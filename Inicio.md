Bienvenido a la guía de preparación para el examen de titulación EGEL+ de Ingeniería de Software. Este examen es una de las herramientas más importantes para la evaluación de los conocimientos y habilidades que adquiriste a lo largo de tu carrera en esta disciplina. El EGEL+ es un examen que se enfoca en medir la capacidad de aplicación de los conocimientos teóricos y prácticos adquiridos en el programa de estudios.

Esta guía de examen no es una recopilación de todos los temas que podrías encontrar en el examen de titulación, sino una selección de los conceptos esenciales que todo ingeniero de software debe dominar y que se esperan sean evaluados en el examen. Estos conceptos son los que te permitirán resolver problemas reales, diseñar soluciones eficientes y aplicar las mejores prácticas de la industria.

La guía de examen está organizada en cuatro secciones principales: análisis de sistemas de software, diseño de sistemas de software, desarrollo de sistemas de software y gestión de proyectos de software. Cada sección contiene segmentos enfocados en temas especifos que de acuerdo a profesores y alumnos son evaluados durante el examen, pero es importante entender que dichos temas no serán expuestos ni cuestionados de forma enciclopedica, por el contrario, se propone el análisis del contenido para resolver problemas y entender el funcionamiento de las cosas. El examen EGEL+ es un ejercicio de razonamiento que rara vez se resuelve memorizando un concepto, por el contrario pide al concursante leer, razonar y exponer porqué su respuesta es la solución a un cuestionamiento.

El objetivo de esta guía de examen es que puedas repasar los conceptos esenciales de forma rápida y efectiva, sin perder tiempo en detalles irrelevantes, redundantes o demasiado especificos. Así, podrás enfocarte en lo que realmente importa y aumentar tus posibilidades de aprobar el examen de titulación con éxito.

# Índice
- [[Área 1. Análisis de sistemas de software]]
	- [[1.1. Tipos de requerimientos]]
		- [[1.1.1. Requerimientos funcionales y no funcionales]]
		- [[1.1.2. Requerimientos de seguridad]]
		- [[1.1.3. Requerimientos de vulnerabilidades de software]]
		- [[1.1.4. Requerimientos de usuario]]
		- [[1.1.5. Requerimientos de negocio]]
		- [[1.1.6. Requerimientos externos (legales, normativos, compliance) — Control y legislación de software]]
		- [[1.1.7. Requerimientos de sistema]]
		- [[1.1.8. Requerimientos de implementación]]
		- [[1.1.9. Requerimientos de optimización]]
		- [[1.1.10. Requerimientos de interfaces]]
		- [[1.1.11. Requerimientos de calidad]]
		- [[1.1.12. Requerimientos de configuración de software]]
		- [[1.1.13. Requerimientos de trazabilidad]]
		- [[1.1.14. Completud, correctitúd, factibilidad y viabilidad de los requerimientos]]
		- [[1.1.15. Características de no ambigüedad]]
		- [[1.1.16. Técnicas para requerimientos - Descomposición funcional, sentencias textuales, modelado de procesos, casos de uso, inspección, prototipos]]
	- [[1.2. Técnicas y herramientas para la obtención, análisis, priorización y validación de requerimientos]]
		- [[1.2.1. Observación]]
		- [[1.2.2. Entrevistas]]
		- [[1.2.3. Encuestas]]
		- [[1.2.4. Cuestionarios]]
		- [[1.2.5. Diagrama de flujo de datos nivel 0 — Diagrama de contexto]]
		- [[1.2.6. Toma de decisiones]]
		- [[1.2.7. Estructura de datos]]
		- [[1.2.8. Mapa de dependencias]]
		- [[1.2.9. Método Delphi]]
		- [[1.2.10. Lluvia de ideas (Brainstorming)]]
		- [[1.2.11. Mesas de trabajo (Talleres o Workshops)]]
		- [[1.2.12. Historias de usuario]]
		- [[1.2.14. Licitaciones]]
	- [[1.3. Técnicas y herramientas de documentación de requerimientos]]
		- [[1.3.1. Visión y alcance de los requerimientos]]
		- [[1.3.2. UML – Casos de uso]]
		- [[1.3.3. Diagrama de proceso empresarial]]
		- [[1.3.4. Matriz de trazabilidad de requerimientos]]
		- [[1.3.5. ETHICS (Implementación efectiva de sistemas informáticos desde punto de vista humano y técnico)]]
		- [[1.3.6. Priorización de requerimientos buy a feature]]
		- [[1.3.7. Priorización de requerimientos cuadrante]]
		- [[1.3.8. Priorización de requerimientos story mapping]]
- [[Área 2. Diseño de sistemas de software]]
	- [[2.1. Diseño arquitectonico de software]]
		- [[2.1.1. Arquitecturas monolíticas, cliente-servidor y multicapa]]
		- [[2.1.2. UML – Diagramas de clases, secuencia, colaboración, estados, plataformas y despliegue]]
		- [[2.1.3. RUP]]
		- [[2.1.4. Diagramas entidad-relación]]
		- [[2.1.5. SysML]]
		- [[2.1.6. Diagrama de flujo (CFD)]]
		- [[2.1.7. ADLs]]
		- [[2.1.8. Patrones de diseño creacionales MVC, DAO, DTO, VO, Facade, Proxy, Adapter, Singleton, Prototype, Composite]]
		- [[2.1.9. Atribute-Driven Design (ADD)]]
		- [[2.1.10. Architecture centric design method (ACDM)]]
		- [[2.1.11. Método de arquitecturas de Rozanski y Woods]]
		- [[2.1.12. Evaluación de arquitectura Architecture Tradeoff Analysis Method (ATAM)]]
		- [[2.1.13. Evaluación de arquitectura Active Reviews for Intermediate Design (ARID)]]
		- [[2.1.14. Evaluación de arquitectura Software Architecture Analysis Method (SAAM)]]
		- [[2.1.15. Evaluación de arquitectura Architecture Spike Skeletons]]
		- [[2.1.16. Documentación 4+1 views]]
		- [[2.1.17. Documentación Views & Beyond]]
		- [[2.1.18. Documentación C4 Model]]
		- [[2.1.19. JAD – Joint Application Design]]
		- [[2.1.20. TOGAF]]
		- [[2.1.21. ISO, IEC, IEEE 42010]]
	- [[2.2. Diseño de módulos, componentes y de datos de software]]
		- [[2.2.1. Estándares para estructurar bases de datos y lenguajes de programación]]
		- [[2.2.2. XML]]
		- [[2.2.3. Bases de datos NoSQL]]
		- [[2.2.4. Diseño de cohesión y niveles]]
		- [[2.2.5. Acoplamiento de componentes (acoplamiento normal, acoplamiento de control, acoplamiento externo, acoplamiento de contenido)]]
		- [[2.2.6. Pseudocódigo]]
		- [[2.2.7. Pilas, colas, listas, árboles y grafos (algoritmos y estructuras de datos)]]
		- [[2.2.8. Algoritmos de ordenamientos y búsquedas]]
		- [[2.2.9. Bases de datos distribuidas]]
		- [[2.2.10. Esquemas de fragmentación en bases de datos distribuidas]]
	- [[2.3. Diseño de interfaces]]
		- [[2.3.1. Ciclo de vida de desarrollo de software]]
		- [[2.3.2. API's]]
		- [[2.3.3. SOA]]
		- [[2.3.4. Servicios Web]]
		- [[2.3.5. UX]]
		- [[2.3.6. REST]]
- [[Área 3. Desarrollo de sistemas de software]]
	- [[3.1. Lenguajes de desarrollo de software]]
		- [[3.1.1. Java]]
		- [[3.1.2. C Sharp]]
		- [[3.1.3. Python]]
		- [[3.1.4. Ruby]]
		- [[3.1.5. PL-SQL]]
		- [[3.1.6. HTML]]
		- [[3.1.7. C++]]
		- [[3.1.8. PHP]]
		- [[3.1.9. JQuery]]
		- [[3.1.10. SOAP y REST]]
	- [[3.2. Paradigmas de la programación]]
		- [[3.2.1. Paradigma imperativo – Programación estructurada, programación procedimental]]
		- [[3.2.2. Paradigma imperativo – Programación estructurada, programación procedimental]]
		- [[3.2.2. Programación Orientada a Objetos (OOP) – Abstracción, herencia, encapsulamiento, polimorfismo]]
		- [[3.2.3. Programación reactiva]]
		- [[3.2.4. Programación orientada a eventos (POE)]]
		- [[3.2.5. Programación orientada a aspectos (POA)]]
	- [[3.3. Entornos de desarrollo]]
		- [[3.3.1. IDE -  Características generales de un IDE]]
		- [[3.3.2. Pruebas de software Unitarias, integración, UAT]]
		- [[3.3.3. Desarrollo en la nube – Azure, AWS]]
		- [[3.3.4. Diferencias y ventajas de entornos locales vs nube]]
		- [[3.3.5. Entornos virtualizados]]
		- [[3.3.6. Fundamentos sistemas operativos]]
		- [[3.3.7. Pruebas de software Funcionales y no funcionales]]
		- [[3.3.8. Control de versiones]]
		- [[3.3.9. Liberaciones Alfa y Beta]]
		- [[3.3.10. Frameworks front-end (CSS, JS) y Backend]]
	- [[3.4. Gestión de datos]]
		- [[3.4.1. SQL]]
		- [[3.4.2. Diccionario de datos]]
		- [[3.4.3. Estructuras relacionales y no relacionales]]
		- [[3.4.4. Manejo de llaves, constraints]]
		- [[3.4.5. Lenguaje de manipulación de datos (DML)]]
		- [[3.4.6. Lenguaje de definición de datos (DDL)]]
		- [[3.4.7. Data mining]]
		- [[3.4.8. Integridad de datos]]
		- [[3.4.9. Funciones, procedimientos y triggers]]
	- [[3.5. Plataformas de desarrollo]]
		- [[3.5.1. PaaS Azure, AWS]]
		- [[3.5.2. Contenedores]]
- [[Área 4. Gestión de proyectos de software]]
	- [[4.1. Gestión de tiempos, costos, recursos humanos y de riesgo]]
		- [[4.1.1. Actores principales en proyectos]]
		- [[4.1.2. WBS]]
		- [[4.1.3. Diagrama Gantt]]
		- [[4.1.4. Diagrama Pert]]
		- [[4.1.5. COCOMO]]
		- [[4.1.6. Análisis FODA]]
		- [[4.1.7. Estimación de costos y tiempos de proyectos]]
		- [[4.1.8. Ruta crítica y holguras]]
		- [[4.1.9. Estimaciones por tres valores]]

