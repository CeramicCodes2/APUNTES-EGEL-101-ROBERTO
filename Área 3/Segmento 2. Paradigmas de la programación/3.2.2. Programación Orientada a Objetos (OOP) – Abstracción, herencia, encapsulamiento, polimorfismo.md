# [[3.6.14. Ruiz, E. (2001). Lenguajes de programación - conceptos y paradigmas, 4(1), pp. 71-74. Industrial Data|Ruiz E. - Lenguajes de programación: Conceptos y paradigmas]]
El paradigma orientado a objetos, se basa en los conceptos de ==objetos y clases de objetos==. ==Un objeto es una variable equipada con un conjunto de operaciones que le pertenecen o están definidas para ellos==. El paradigma orientado a objetos actualmente ==es el paradigma más popular== y día a día los programadores, estudiantes y profesionales tratan de tomar algún curso que tenga que ver con este paradigma, podría decirse, que programar orientado a objetos está de moda.  
  
Alrededor de 1970 David Parnas planteó el ==ocultamiento de la información como una solución al problema de gerenciar grandes proyectos software==. Su idea fue ==encapsular cada variable global en un módulo con un grupo de operaciones== (al igual que los procedimientos y las funciones) ==que permitan tener un acceso directo a la variable==. Otros módulos pueden acceder a la variable sólo indirectamente, llamando a estas operaciones. Hoy se usa el ==término objeto para tales módulos o variables encapsuladas a sí mismas==. Lenguajes imperativos como ==Pascal Y C han sido modificados (o añadidos) para que soporten el paradigma orientado a objetos para dar Delphi en el caso de Pascal y C++ en el caso de C==.  
  
Una de las bondades importantes de los lenguajes orientados a objetos es que ==las definiciones de los objetos pueden usarse una y otra vez para construir múltiples objetos con las mismas propiedades o modificarse para construir nuevos objetos con propiedades similares pero no exactamente iguales==.  
  
==El lenguaje orientado a objetos por excelencia es Smaltalk== desarrollado en Palo Alto Research Center durante los 1970's.  
  
Pero que es exactamente un lenguaje orientado a objetos- Los siguientes conceptos señalan las características generalmente aceptadas acerca de los lenguajes orientados a objetos.

- Objetos y clases son obviamente los conceptos fundamentales. ==Una clase es un conjunto de objetos que comparten las mismas operaciones==.      
- Objetos (o al menos referencia a objetos) ==deben ser valores de la clase base==. Así, ==cualquier operación puede tomar un objeto como un argumento y puede devolver un objeto como resultado==. De esta manera el concepto de clase de objetos está relacionado con el concepto de tipo de dato.  
- Herencia es también vista como un concepto clave dentro del mundo de los objetos. En este contexto, ==la herencia es la habilidad para organizar las clases de objetos en una jerarquía de subclases y superclases y las operaciones dadas para una clase se pueden aplicar a los objetos de la subclase==.
# ChatGPT
La programación orientada a objetos (POO) es un ==paradigma de programación que se basa en la organización del código en torno a objetos, que son instancias de clases==. Los objetos representan ==entidades del mundo real y contienen datos (atributos) y funciones (métodos) que operan en esos datos==. La POO se centra en la encapsulación, la herencia y el polimorfismo para facilitar la reutilización de código y la modelación de sistemas complejos.
## Abstracción
La abstracción es un concepto en programación que implica ==simplificar y enfocarse en los aspectos más relevantes de un objeto o entidad==, mientras se omiten los detalles innecesarios. ==Funciona al ocultar la complejidad interna y proporcionar una interfaz sencilla para interactuar con un objeto==.

Un ejemplo de abstracción en programación podría ser una clase que representa una bicicleta. Aunque una bicicleta real es una máquina compleja con numerosos componentes, desde un punto de vista abstracto, podemos representarla con una interfaz simplificada y centrarnos en los aspectos esenciales.

Aquí tienes un ejemplo en Python:
```python
class Bicicleta:
    def __init__(self, color, tipo):
        self.color = color
        self.tipo = tipo
        self.velocidad = 0

    def acelerar(self):
        self.velocidad += 10

    def frenar(self):
        self.velocidad -= 5

    def estado(self):
        print(f"Bicicleta {self.color} de tipo {self.tipo}. Velocidad: {self.velocidad} km/h")

# Crear una instancia de la clase Bicicleta
mi_bicicleta = Bicicleta("Roja", "Montaña")

# Interactuar con la bicicleta sin necesidad de conocer los detalles internos
mi_bicicleta.acelerar()
mi_bicicleta.acelerar()
mi_bicicleta.frenar()
mi_bicicleta.estado()
```
## Herencia
La herencia en programación orientada a objetos (POO) es un ==concepto que permite a una clase== (llamada "clase hija" o "subclase") ==heredar atributos y métodos de otra clase== (llamada "clase padre" o "superclase"). Esto ==facilita la reutilización de código y permite definir nuevas clases basadas en clases existentes==, lo que ==promueve la jerarquía y la estructura== en la programación orientada a objetos.

Un ejemplo simple de herencia en programación orientada a objetos podría ser una jerarquía de clases que representan vehículos. Aquí tienes un ejemplo en Python:

```python
# Clase base (superclase)
class Vehiculo:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

    def mostrar_informacion(self):
        print(f"Marca: {self.marca}, Modelo: {self.modelo}")

# Clase derivada (subclase)
class Coche(Vehiculo):
    def __init__(self, marca, modelo, puertas):
        # Llamamos al constructor de la superclase
        super().__init__(marca, modelo)
        self.puertas = puertas

    def mostrar_informacion(self):
        # Sobreescribimos el método de la superclase
        print(f"Coche - Marca: {self.marca}, Modelo: {self.modelo}, Puertas: {self.puertas}")

# Crear una instancia de la subclase
mi_coche = Coche("Toyota", "Corolla", 4)

# Llamar a un método de la subclase
mi_coche.mostrar_informacion()
```
## Encapsulamiento
El encapsulamiento es un concepto en programación orientada a objetos que ==implica el ocultamiento de los detalles internos de un objeto y la protección de sus datos y métodos==. Esto se logra al ==definir atributos como privados o protegidos y proporcionar métodos públicos para acceder y modificar esos atributos==. El encapsulamiento ayuda a mantener la integridad de los datos y promueve la modularidad y la reutilización del código.

Un ejemplo de encapsulamiento en programación orientada a objetos podría ser una clase que representa una cuenta bancaria. En este caso, los detalles internos de la cuenta, como el saldo, se ocultan y se acceden y modifican a través de métodos públicos.

Aquí tienes un ejemplo en Python:
```python
class CuentaBancaria:
    def __init__(self, titular, saldo_inicial):
        self.titular = titular
        # Atributo privado, no accesible directamente desde fuera de la clase
        self.__saldo = saldo_inicial

    # Método público para depositar dinero
    def depositar(self, cantidad):
        if cantidad > 0:
            self.__saldo += cantidad

    # Método público para retirar dinero
    def retirar(self, cantidad):
        if 0 < cantidad <= self.__saldo:
            self.__saldo -= cantidad

    # Método público para obtener el saldo
    def obtener_saldo(self):
        return self.__saldo

# Crear una instancia de la clase CuentaBancaria
mi_cuenta = CuentaBancaria("Juan", 1000)

# Acceder y modificar el saldo a través de métodos públicos
mi_cuenta.depositar(500)
mi_cuenta.retirar(200)

# Obtener el saldo
print(f"Saldo de la cuenta de {mi_cuenta.titular}: ${mi_cuenta.obtener_saldo()}")
```

En este ejemplo, el saldo de la cuenta (`__saldo`) se mantiene como un atributo privado, y se proporcionan métodos públicos (`depositar`, `retirar` y `obtener_saldo`) para interactuar con él. Esto es un ejemplo de encapsulamiento, ya que se ocultan los detalles internos de la cuenta y se acceden y modifican sus datos a través de métodos públicos, lo que protege la integridad de los datos.
## Polimorfismo
El polimorfismo es un concepto en programación orientada a objetos que ==permite a objetos de diferentes clases responder de manera similar a mensajes o métodos comunes==. Esto significa que ==objetos de clases diferentes pueden ser tratados de la misma manera si implementan métodos con los mismos nombres o firmas==. El polimorfismo facilita la ==flexibilidad y la reutilización del código== al permitir el uso de interfaces comunes para objetos diversos.

Un ejemplo de polimorfismo en programación orientada a objetos podría ser el uso de una interfaz o una clase base para trabajar con diferentes tipos de formas geométricas, como círculos y rectángulos. Cada forma implementa un método llamado "calcular_area()" de manera específica, pero puede ser tratada de manera similar a través de una interfaz común. 

Aquí hay un ejemplo en Python:
```python
class FormaGeometrica:
    def calcular_area(self):
        pass

class Circulo(FormaGeometrica):
    def __init__(self, radio):
        self.radio = radio

    def calcular_area(self):
        return 3.1415 * self.radio * self.radio

class Rectangulo(FormaGeometrica):
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    def calcular_area(self):
        return self.base * self.altura

# Función que utiliza polimorfismo para calcular el área de una forma geométrica
def calcular_y_mostrar_area(forma):
    area = forma.calcular_area()
    print(f"Área: {area}")

# Crear instancias de diferentes formas geométricas
circulo = Circulo(5)
rectangulo = Rectangulo(4, 6)

# Calcular y mostrar áreas utilizando la misma función
calcular_y_mostrar_area(circulo)
calcular_y_mostrar_area(rectangulo)
```

En este ejemplo, las clases `Circulo` y `Rectangulo` heredan de la clase base `FormaGeometrica` y sobrescriben el método `calcular_area()`. La función `calcular_y_mostrar_area` utiliza polimorfismo para calcular y mostrar el área de diferentes formas geométricas, ya que trata todas las formas como objetos de la clase base, pero sus implementaciones específicas del método son utilizadas en tiempo de ejecución. Esto es un ejemplo de polimorfismo, ya que objetos de clases diferentes pueden responder al mismo mensaje ("calcular_area()") de manera específica.